% Nejprve uvedeme tridu dokumentu s volbami
\documentclass[ing,male,java,dept456]{diploma}						% jednostranny dokument
%\documentclass[bc,female,java,dept456,twoside]{diploma}		% oboustranny dokument
\usepackage[czech]{babel}
\usepackage[utf8]{inputenc}


\usepackage{color}
\usepackage{setspace}
\usepackage[usenames,dvipsnames]{xcolor}
\definecolor{SQLKeywords}{RGB}{0,0,127}
\definecolor{SQLStrings}{RGB}{127,0,127}
\definecolor{SQLNumbers}{RGB}{0,127,127}
\definecolor{Code}{rgb}{0,0,0}
\definecolor{Decorators}{rgb}{0.5,0.5,0.5}
\definecolor{Numbers}{rgb}{0.5,0,0}
\definecolor{MatchingBrackets}{rgb}{0.25,0.5,0.5}
\definecolor{Keywords}{rgb}{0,0,1}
\definecolor{self}{rgb}{0,0,0}
\definecolor{Strings}{rgb}{0,0.63,0}
\definecolor{Comments}{rgb}{0,0.63,1}
\definecolor{Backquotes}{rgb}{0,0,0}
\definecolor{Classname}{rgb}{0,0,0}
\definecolor{FunctionName}{rgb}{0,0,0}
\definecolor{Operators}{rgb}{0,0,0}
\definecolor{Background}{rgb}{0.98,0.98,0.98}
\lstdefinestyle{custompython}{
showspaces=false,
showtabs=false,
showstringspaces=false,
tabsize=4,
numberstyle=\footnotesize,
numbersep=1em,
% Basic
basicstyle=\ttfamily\small\mdseries\setstretch{1},
language=Python,
literate=%
	{0}{{{\color{Numbers}0}}}1
    {1}{{{\color{Numbers}1}}}1
    {2}{{{\color{Numbers}2}}}1
    {3}{{{\color{Numbers}3}}}1
    {4}{{{\color{Numbers}4}}}1
    {5}{{{\color{Numbers}5}}}1
    {6}{{{\color{Numbers}6}}}1
    {7}{{{\color{Numbers}7}}}1
    {8}{{{\color{Numbers}8}}}1
    {9}{{{\color{Numbers}9}}}1
    {á}{{\'a}}1 
	{é}{{\'e}}1 
	{í}{{\'i}}1 
	{ó}{{\'o}}1 
	{ú}{{\'u}}1 
	{ý}{{\'y}}1
	{č}{{\v{c}}}1
%	{ď}{{\v{d}}}1
	{ě}{{\v{e}}}1
%	{ň}{{\v{n}}}1	
	{ř}{{\v{r}}}1
	{š}{{\v{s}}}1
%	{t}{{\v{ť}}}1
	{ž}{{\v{z}}}1
	{ě}{{\v{e}}}1
	{ů}{\r u}1,
% Comments
commentstyle=\color{Gray}\slshape,
% Strings
stringstyle=\color{Strings}\slshape,
morecomment=[s][\color{Strings}\slshape]{"""}{"""},
morecomment=[s][\color{Strings}\slshape]{'''}{'''},
% keywords
morekeywords={import,from,class,def,for,while,if,is,in,elif,else,not,and,or,print,break,continue,return,True,False,None,access,as,,del,except,exec,finally,global,import,lambda,pass,print,raise,try,assert},
keywordstyle={\color{Keywords}\bfseries},
% additional keywords
morekeywords={[2]@invariant},
keywordstyle={[2]\color{Decorators}\slshape},
emph={self},
emphstyle={\color{self}\slshape},
inputencoding=utf8,
extendedchars=true,
}
\lstdefinestyle{customsql}{
language=SQL,
morekeywords={DEFERRED, REFERENCES, text},
keywordstyle=\color{SQLKeywords},
stringstyle=\color{SQLStrings},
literate=%
	{0}{{{\color{SQLNumbers}0}}}1
    {1}{{{\color{SQLNumbers}1}}}1
    {2}{{{\color{SQLNumbers}2}}}1
    {3}{{{\color{SQLNumbers}3}}}1
    {4}{{{\color{SQLNumbers}4}}}1
    {5}{{{\color{SQLNumbers}5}}}1
    {6}{{{\color{SQLNumbers}6}}}1
    {7}{{{\color{SQLNumbers}7}}}1
    {8}{{{\color{SQLNumbers}8}}}1
    {9}{{{\color{SQLNumbers}9}}}1,
}
%abstrakt, datovy slovnik
% Zadame pozadovane vstupy pro generovani titulnich stran.
\Author{David Krutký}

\Title{Optimalizace datové vrsty aplikací pro PostgreSQL}

\EnglishTitle{Optimization of a Data Layer of an Application Using PostgreSQL}

\SubmissionDate{7. května 2013}

\PrintPublicationAgreement{true}

\Thanks{Rád bych na tomto místě poděkoval všem, kteří mi pomohli, protože bez nich by tato práce nevznikla.}

\CzechAbstract{Abstrakt cz}

\CzechKeywords{Keywords cz}

\EnglishAbstract{Abstrakt en}

\EnglishKeywords{Keywords en}

% Pridame pouzivane zkratky (pokud nejake pouzivame).
\AddAcronym{TL;DR}{Too long; didn't read}

% Zacatek dokumentu
\begin{document}

% Nechame vysazet titulni strany.
\MakeTitlePages

% Asi urcite budeme potrebovat obsah prace.
\tableofcontents
\cleardoublepage	% odstrankujeme, u jednostranneho dokumentu o jednu stranku, u oboustrenneho o dve

% Jsou v praci tabulky? Pokud ano vysazime jejich seznam.
% Pokud ne smazeme nasledujici makro.
\listoftables
\cleardoublepage	% odstrankujeme, u jednostranneho dokumentu o jednu stranku, u oboustrenneho o dve

% Jsou v praci obrazky? Pokud ano vysazime jejich seznam.
\listoffigures
\cleardoublepage	% odstrankujeme, u jednostranneho dokumentu o jednu stranku, u oboustrenneho o dve


% Jsou v praci vypisy programu? Pokud ano vysazime jejich seznam.
\lstlistoflistings
\cleardoublepage	% odstrankujeme, u jednostranneho dokumentu o jednu stranku, u oboustrenneho o dve

% Zacneme uvodem
\section{Úvod}
\label{sec:Intro}
Systémy řízení báze dat (SŘBD) jsou dnes nejpoužívanějšími systémy pro ukládání dat v aplikačním softwaru. Nejrozšířenějším typem databázových systému jsou databáze relační. Na problém, který představuje komunikace aplikačního softwaru s relačním databázovým systémem, se zaměřuje tato diplomová práce.
V kapitole jsou popsány a vysvětleny základní pojmy spojené s relačními databázemi a přístupu k nim.
Důvod, který mě vedl pro vytvoření nové knihovny popisuje kapitola. 

\section{Vrstvená architektura}

Použití vrstev je jedna z nejčastějších technik využívaných pro zjednodušení komplexnosti složitých systémů \cite{fowler}. Vrstvy ve vrstvené architektuře popisují logické seskupení funkcí a komponent v aplikaci. Shlukují komponenty podle typu funkcí a ulehčují tak jejich znovupoužitelnost. Vrstvy nemusí být přitom ani fyzicky oddělené, pouze vymezují a rozdělují aplikaci do logických celků. Každá z vrstev této architektury komunikuje pouze se svými sousedními vrstvami a nestará se o další části systému. Vrstva na nižší úrovni poskytuje rozhraní, které je známé vrstvě o úroveň výše. Tato architektura tak umožňuje jednoduše nahradit nebo změnit jednotlivé vrstvy, aniž by to ovlivnilo ostatní vrstvy. \\
Při vytváření aplikace založené na této architektuře je tak možno postupovat ve vývoji jednotlivých vrstev souběžně. Tohoto je dosaženo pomocí předem určeného rozhraní. Mezi další výhody patří také jednodušší údržba a testování, kde lze využít i tzv. mock-up testů. \\
Nevýhodou vrstev je, že při vysokém počtu se můžou velmi negativně projevovat na výkonu celého systému. Nejvýraznějším vlivem je potřeba rozhraní pro převod dat, jelikož každá z vrstev má vlastní logiku a interpretuje data vlastním způsobem. Dalším problémem jsou změny, které ovlivňují všechny vrstvy o úroveň výše tzv. kaskádové změny \cite{dresler}. V informačních systémech to může být například přidání databázového sloupce. \\
Vrstvenou architekturu lze aplikovat nezávisle na typu aplikace \cite{msdn}. Příkladem použití této architektury je referenční model ISO/OSI\footnote{ http://standards.iso.org/ittf/PubliclyAvailableStandards/s020269\_ISO\_IEC\_7498-1\_1994(E).zip}. \\

\subsection{Třívrstvá architektura}

Jedním z nejrozšířenějších typů vrstvené architektury v aplikacích je třívrstvá architektura. Mezi vrstvy třívrstvé architektury patří vrstvy prezentační, aplikační a datová. \\
Úkolem prezentační vrstvy je zobrazovat uživateli data ve srozumitelné a přehledné formě, reagovat na jeho požadavky a propagovat provedené změny. Prezentační vrstva může mít podobu uživatelského rozhraní v aplikaci, webové stránky nebo i jednoduchého rozhraní příkazové řádky. \\
Aplikační vrstva je srdcem aplikace. V této vrstvě se vyskytuje veškerá aplikační logika, pracuje se zde s daty, které se validují, provádějí se na nich výpočty a připravují se k uložení nebo k zobrazení. Spadají zde funkce jako autentifikace, autorizace, logování a kešování. \\
Datová vrstva zajišťuje manipulaci se zdrojem dat nebo datovým úložištěm a s daty, které tyto úložiště poskytují. Abstrahuje a centralizuje přístup k tomuto úložišti dat. Důležitým úkolem datové vrstvy je také bezpečnost dat a jejich ochrana před případnými pokusy, které se snaží k těmto datům získat přístup nebo je poškodit. Datová vrstva by se také měla snažit o co nejefektivnější výkonnost a škálovatelnost, jelikož často bývá nejvíce zatěžovaným místem v aplikaci. \\

\subsection{Datová vrstva aplikačního softwaru}
\label{subsec:Data-layer}
Velice často je třeba, aby data zpracovávaná aplikací byla perzistentní. Tímto pojmem se rozumí trvalé zachování dat po zastavení provozu aplikace nebo i po výpadku systému. Jako nástroje poskytující tuto funkci jsou dnes hojně rozšířené relační databáze. \\
Princip datové vrstvy při použití relačních databází zůstává stejný. Mezi její funkce patří:
\begin{itemize}
\item správa spojení,
\item řízení paralelního zpracování a transakce,
\item synchronizace konkurenčních dat v aplikaci a v databázi,
\item validace dat,
\item formátování dat,
\item dotazování a získávání dat z databáze,
\item persistence dat,
\item správa chyb a chybových hlášení,
\item zajištění bezpečnosti dat,
\item dávkování dotazů,
\item stabilita a efektivní výkon.
\end{itemize}

Datová vrstva musí také řešit problém, který představuje nekompatibilita objektových jazyků použitých pro aplikační logiku a dotazovacích jazyků využívaných pro získávání dat z relačních databází. Tento problém označujeme pod pojmem \textit{Impedance mismatch}. Do tohoto problému spadá například převod syntaxe, převod datových typů, efektivní interpretace relací a struktur a jejich mapování mezi dvěma nekompatibilními jazyky. \\
Impedance mismatch se začal více projevovat až při použití objektově orientovaných jazyků. Jazyky používané dříve měly specializované datové struktury optimalizované pro zacházení s relačními daty, kdežto objektově orientovaným jazykům tyto struktury schází \cite{dbprogrammer}. \\

Pro zjednodušení a odstínění od těchto problémů byly vytvořeny rámce a knihovny, které se starají o tyto monotonní činnosti. Rozdíl mezi knihovnou a rámcem definuje Martin Fowler pomocí \textit{Inversion of control}. Knihovna poskytuje funkce, které je možné v aplikační logice využívat. Je tedy řízena aplikační logikou. Naopak při použití rámce je třeba umístit aplikační kód na předem určené místa například pomocí dědičnosti. Tento kód je pak volán a řízen rámcem \cite{fowler-ioc}.  \\

Datová vrstva se v angličtině označuje pod názvem \textit{Data-Access Layer} (DAL). Tímto pojmem se také někdy nazývají knihovny a rámce, které zastávají funkci této vrstvy. Často se tento název plete s \textit{Database-Abstraction Layer} (DBAL). DBAL je typ DAL, který pomocí svých funkcí abstrahuje rozdíly mezi detaily a specifikacemi podporovanými SŘBD. Umožňuje tak jednodušeji změnit SŘBD bez velkých úprav aplikačního kódu. \\

Samotná datová vrstva je velmi často rozdělena na další podvrstvy. Mezi nejprimitivnější DAL patří knihovny, které označujeme za konektory nebo ovladače. Řeší pouze část problému Impedance mismatch, poskytují základní funkce a zaměřují se pouze na jeden SŘBD. Zpravidla umožňují zadat pouze syrové SQL ve formě řetězce. Tyto konektory se většinou řídí podle specifikovaných standardů. Mnoho programovacích jazyků má určeno tyto standardy proto, aby sjednotily rozhraní a práci s těmito knihovnami, což umožňuje lehčí přechod mezi SŘBD a jednodušší vytváření DBAL. Příkladem standardu pro jazyk Python je specifikace PEP 249\footnote{http://www.python.org/dev/peps/pep-0249/} .\\
Konektory pak využívají již zmíněné DBAL a složitější rámce a knihovny snažící se o větší míru abstrakce. Tyto tak tvoří další vrstvu. \\
Nad touto vrstvou je dnes velmi často postavena ještě další funkčnost mající za cíl problém Impedance mismatch ještě více ulehčit a abstrahovat. Touto funkčností je objektově relační mapování, v angličtině \textit{Object-Relational Mapping} (ORM). ORM zle považovat za nejvyšší míru abstrakce ze všech typů DAL.  \\

%Pripadne do budoucna...
%Pro zjednodušení budu tyto knihovny považovat za první vrstvu datové vrstvy. Tyto knihovny a rámce řadím do vrstvy druhé. Řadím ji do třetí vrstvy datové vrstvy...
%Obrázek zobrazuje rozdělení známých rámců a knihoven do těchto tří vrstev, které jsem definoval výše.

Příkladem DAL jsou knihovny a rámce psycopg2, MySQL Connector/NET, PDO, JDBC, Hibernate, SQLAlchemy. Z toho lze považovat psycopg2, MySQL Connector/NET za koknektory, PDO, JDBC, Hibernate, SQLAlchemy za DBAL a Hibernate a SQLAlchemy za ORM.

\section{Objektově relační mapování}

Objektově relační (O/R) mapovaní, jak už název napovídá, mapuje entity z relačního modelu na doménové objekty v aplikační logice nejčastěji pomocí objektů nebo tříd. \\
Pod pojmem doména rozumíme u aplikace oblast z reálného světa, pro kterou se tato aplikace snaží vyřešit nebo zjednodušit specifický problém. Doména vymezuje rozsah působnosti aplikace a určuje doménové objekty. Tyto objekty se v objektově orientovaném jazyce modelují nejčastěji pomocí tříd. Například, pokud je doména nákup a prodej zboží, za doménové objekty lze považovat kupujícího a objednávku. Martin Fowler definuje ve své publikaci několik návrhových vzorů, které popisují modelování doménových objektů a přístup k doménové logice. Mezi tyto vzory patří \textit{Transaction Script}, \textit{Domain Model} a \textit{Table Module} \cite{fowler}. Popis těchto vzorů je nad rámec této diplomové práce. Tyto návrhové vzory se však berou v potaz při návrhu objektově relačního mapování. \\
Podobně jako u DAL se i pod zkratkou ORM někdy označují rámce implementující O/R mapovaní. Tyto rámce kromě O/R mapování obsahují funkce potřebné pro komunikaci s relační databází popsané výše v sekci \ref{subsec:Data-layer}. Někdy i využívají existujících DAL, které tyto funkce obsahují a přidávají k nim O/R mapování. Většinou obsahují také DBAL. \\

\subsection{Rozhraní datové vrstvy}

Každé ORM definuje způsob, kterým datová vrstva komunikuje s aplikační vrstvou. Tímto rozhraním ORM také abstrahuje přístup k databázi a z části určuje i architekturu doménové logiky. Martin Fowler pojmenoval několik základních typů a návrhových vzorů pro toto rozhraní jako \textit{Table Data Gateway}, \textit{Row Data Gateway}, \textit{Active Record} a \textit{Data Mapper} \cite{fowler}. Ve všech případech jsou v objektově orientovaném jazyce jako rozhraní využity třídy, pomoci kterých ORM abstrahuje tabulky, pohledy, dynamické 	dotazy nebo dotazy zapouzdřené v uložených procedurách. Vzory se mezi sebou liší způsobem jakým jsou tyto třídy využity a typem abstrakce.

\subsubsection{Table Data Gateway}

Table Data Gateway využívá třídy jako brány k tabulkám. Tabulka nebo podobný databázový objekt je namapována pomocí třídy. Třída obsahuje metody pouze pro ukládání, mazání a vyhledávání v datech tabulky. Jedna instance této třídy přitom poskytuje rozhraní ke všem záznamům v tabulce.  Ke konkrétnímu řádku tabulky se lze dostat jen předáním klíče, jedinečného identifikátoru. Tento návrhový vzor je ve většině případů bezstavový. \\
Každá metoda třídy abstrahující tabulku skrývá za svým rozhraním SQL. Nejčastěji komunikuje přímo s databázovým ovladačem a předává mu vytvořené SQL. Data jsou pak vrácena ve formě v jaké je vrací ovladač, v objektu typu \textit{Record Set}. Record Set je generická reprezentace relačních dat v paměti, většinou podobná poli nebo seznamu. Metody pro vyhledávání v datech pak vracejí vždy tento objekt, i pokud se jedná pouze o jediný záznam. Vrácená data navíc neobsahují žádnou referenci k tomuto rozhraní. Toto může být problém a proto se vrácená data někdy obalují dalším objektem. Tento objekt se označuje jako \textit{Data Transfer Object} \cite{fowler}. \\
Výhodou při použití tohoto vzoru je, že jeho rozhraní lze využít jak pro manipulaci relačních dat, tak pro uložené procedury. Také shlukuje SQL na jedno místo, což zjednodušuje optimalizaci. Table Data Gateway lze lehce využít jako rozhraní datové vrstvy při použití vzorů Table Module nebo Transaction Stript v aplikační logice. \\
Příkladem tohoto návrhového vzoru je obrázek \ref{fig:TableDataGateway}. Na obrázku je třída PersonGateway, která slouží jako brána k databázové tabulce Person.

\InsertFigure{tabledatagateway.png}{80mm}{Třída v návrhovém vzoru Table Data Gateway \cite[str. 148]{fowler}}{fig:TableDataGateway}

\subsubsection{Row Data Gateway}

Row Data Gateway abstrahuje tabulku pomocí třídy, její záznamy pomocí instancí této třídy a její sloupce pomocí atributů. Třídy neobsahují žádnou aplikační logiku a slouží pouze jako brána k datům. Jedna instance odpovídá jednomu záznamu. Lze se tak jednoduše dostat ke konkrétnímu řádku. Instance má navíc povědomí o celém rozhraní, není tedy třeba používat Data Transfer Object. \\
Instance obsahuje metody pro manipulaci s daty řádku, jejich mazání a ukládání. Datové typy atributů třídy jsou implicitně převáděny na datové typy konkrétních sloupců tabulky. Na základě tříd a jejich atributů, lze i jednoduše vytvořit pomocí nástrojů ORM relační schéma v databázi. \\
Ke každé třídě mapující tabulku je vytvořena další třída, která slouží k vyhledávání záznamů v této tabulce. Tato třída se v pozadí chová podobně jako třída v návrhovém vzoru Table Data Gateway, a je tak možné využívat i některých výhod tohoto vzoru. Namísto objektu Record Set však třída pro vyhledávání vrací instanci třídy abstrahující tabulku. Pro získání záznamu je tedy nejdříve nutné využít vyhledávací třídu. \\
Příklad návrhového vzoru Row Data Gateway zobrazuje obrázek \ref{fig:RowDataGateway}. Na obrázku je třída PersonFinder, která vyhledává data v databázové tabulce Person a vrací instanci třídy PersonGateway. PersonGateway pak slouží jako rozhraní pro konkrétní řádek tabulky Person. \\

\InsertFigure{rowdatagateway.png}{40mm}{Ukázka použití návrhového vzoru Row Data Gateway \cite[str. 154]{fowler}}{fig:RowDataGateway}

\subsubsection{Active Record}
\label{subsubsec:ActiveRecord}

Active Record je návrhový vzor podobný Row Data Gateway. Stejně jako Row Data Gateway mapuje struktury v datové vrstvě velmi úzce se strukturou databáze. Třídy tak korespondují s tabulkami v databázi a jejich instance a atributy s řádky a sloupci tabulek. Oproti Row Data Gateway však třídy obsahují navíc i aplikační logiku a většinou jsou tak považovány i za doménové objekty. \\
\uv{Třída ve vzoru Active Record typicky obsahuje metody, které mají za úkol následující:
\begin{itemize}
\item Vytvořit instanci třídy z dat řádku vráceného na SQL dotaz
\item Vytvořit instanci třídy, která bude později použita pro vložení nového záznamu do tabulky
\item Statické metody, které obalují často používané SQL dotazy pro vyhledávání dat a které vracejí instance třídy
\item Aktualizovat databázi daty instance
\item Metody pro získání a nastavování hodnot atributů
\item Implementace části aplikační logiky
\end{itemize}}\cite[str. 160]{fowler} \\
Tento návrhový vzor je intuitivním přístupem, pokud při návrhu databázového schématu korespondují tabulky s doménovými objekty. Proto a pro svou jednoduchost je dnes velmi rozšířeným a často používaným vzorem při návrhu ORM. Používá se hlavně pro jednoduché systémy, kterým umožňuje rychlou implementaci rozhraní datové vrstvy. \\
Mezi nevýhody návrhového vzoru Active Record patří mapování vztahů a dědičnosti, které z části rozbíjí jeho principy a přispívají tak ke špatné struktuře kódu a chybám, které z toho plynou. Podobný problém nastává při složitější aplikační logice, jelikož pak třídy výrazně nabudou na objemu a zastávají nemalý počet funkcí. Toto vede ke špatně testovatelným objektům a nevyhnutelně k chybám. Active Record se nevyplatí používat, pokud se doménové objekty liší od struktur v databázi nebo pokud by v budoucnu mohlo k takovýmto změnám dojít.

\subsubsection{Data Mapper}

Data Mapper se využívá při složitější aplikační logice, při rozdílném objektovém a relačním schématu nebo často i pokud je třeba pracovat s již existující databází. Doménové objekty v aplikační logice se při použití tohoto vzoru nemusí shodovat s databázovým schématem. Lze je vytvořit naprosto nezávisle. Je tak možné kdykoliv změnit databázové schéma nebo struktury v aplikační logice, z čehož vyplývá mnoho výhod. \\
Nevýhodou tohoto přístupu je, že přidává další vrstvu mezi databázi a aplikační vrstvu. Toto se může negativně projevovat na celkovém výkonu a složitosti systému, proto se Data Mapper nedoporučuje používat pro jednoduché případy, které lze vyřešit například pomocí vzoru Active Record.\\
Data Mapper komunikuje s aplikační vrstvou pomocí mapovací třídy, která poskytuje rozhraní k získávání doménových objektů. Mapovací třída může abstrahovat jednu databázovou tabulku, její část nebo i více tabulek. Většinou je výhodnější pro jednu doménovou třídu vytvořit vždy jednu mapovací třídu. \\
Obrázek \ref{fig:DataMapper} zobrazuje jednoduchý příklad návrhového vzoru Data Mapper. Na obrázku je  mapovací třída PersonMapper, která získává data z databáze a vrací je ve formě instancí doménové třídy Person. PersonMapper poskytuje metody i pro ukládání a mazání těchto instancí. Implementace získávání dat je před třídou Person skrytá a databázové schéma může vypadat jakkoliv. \\
Data Mapper využívá pro spravování doménových objektů strukturu pojmenovanou jako \textit{Identity Map} \cite{fowler}. Tato struktura se stará o synchronizaci doménových objektů a dat v paměti. Předchází provádění zbytečných dotazů do databáze, pokud daný objekt již v paměti existuje a zajišťuje, aby v takovém případě místo nového objektu byla vrácena reference na existující objekt. \\
Tento návrhový vzor má smysl používat jen tehdy, pokud se aplikační logika řídí vzorem Domain Model. Při použití jiných vzorů přináší Data Mapper mnoho nadbytečných komplikací a jeho použití se nevyplácí. \\

\InsertFigure{datamapper.png}{105mm}{Ukázka použití návrhového vzoru Data Mapper \cite[str. 164]{fowler}}{fig:DataMapper}

\subsection{Mapování vztahů}
\label{subsec:Relmapping}

V relační databázi se používají cizí klíče pro vyjádření relací, ale objekty v objektově orientovaných jazycích dosahují vazeb za pomocí referencí na vazební objekt. ORM tento problém řeší mapováním vztahů.\\
Mapování vztahů a relací patří mezi základní funkce ORM. ORM řídící se podle návrhových vzorů Row Data Gateway, Active Record a Data Mapper tuto funkci potřebují, jelikož mapují instance tříd, které abstrahují databázové tabulky, na záznamy těchto tabulek. \\
ORM poskytuje mapování pro všechny druhy binárních relací. \\
\textbf{Relace N:1 nebo 1:1} se mapuje nejjednodušeji. Řádek s cizím klíčem v relační databázi je namapován pomocí objektu, který obsahuje referenci na objekt mapující záznam odkazovaný cizím klíčem. \\
\textbf{Relace 1:N} je v relační databázi řešena opačným způsobem než v objektově orientovaných jazycích. Záznamy databázové tabulky Město obsahují cizí klíč na tabulku Stát, ale instance třídy Stát obsahují kolekci s referencemi na objekty třídy Město. ORM mapováním zajišťuje naplnění této kolekce vetšinou pomocí dodatečného dotazu do databáze, anebo spojením tabulek ihned při získávání objektu třídy Stát. \\
\textbf{Relace N:M} se v relační algebře řeší pomocí vazební tabulky, v objektově orientovaném jazyce to však potřeba není. Objekty mohou totiž jako v případě 1:N obsahovat kolekce s referencemi na vazební objekty. Úkolem ORM je tyto kolekce naplnit, což je zajištěno opět spojením tabulek nebo dodatečným dotazem. Komplikované je v tomto případě i zabezpečení integrity dat. ORM by mělo integritu dat zajišťovat, a to nejlépe za pomoci Identity Map. \\
Problémem, který musí ORM v souvislosti s mapováním vazeb řešit je nahrávání vazebních objektů do paměti. Nelze všechny vazby nahrávat najednou, protože hrozí, že by se do paměti načetlo velké množství dat, v nejhorším případě celá databáze. ORM proto většinou poskytuje funkci \textit{Lazy Loading}. Lazy Loading zajišťuje, že při načtení objektu z databáze do paměti se data, které tvoří relaci, nenahrají ihned, ale až při přístupu k dané relaci. \\
Toto chování však také není vždy ideální, jelikož v určitých případech tak ORM může generovat mnoho přístupů do databáze, které by se daly jinak ušetřit. ORM by proto mělo sledovat, jak aplikační vrstva pracuje s objekty a podle toho nahrávat jejich vazby. 

\subsection{Mapování dědičnosti}
\label{subsec:Inhmapping}
Objektově relační mapování definuje principy, pomocí kterých je možné mapovat dědičnost objektově orientovaných jazyků v relačních databázích. V současné době většina databází dědičnost přímo nepodporuje a neexistuje standard, který by tuto funkčnost pro databáze specifikoval. ORM proto často obsahuje funkce, které umožňují dědičnost různými způsoby simulovat. \\
Dědičnost je jedním z hlavních prvků objektově orientovaných jazyků a prostřednictvím ORM je možné ji využívat při definici tříd, kterými ORM abstrahuje databázové tabulky. Mapování dědičnosti je možné dosáhnout třemi způsoby, které Martin Fowler pojmenovává jako \textit{Single Table Inheritance}, \textit{Concrete Table Inheritance} a \textit{Class Table Inheritance} \cite{fowler}. \\
Nevýhodou tohoto mapování je složitější struktura tabulek a z toho plynoucí zhoršení výkonu operací prováděných nad databází. Obrázek \ref{fig:Inheritance} zobrazuje příklady těchto tří návrhových vzorů.

\InsertFigure{inheritance.png}{150mm}{Ukázka návrhových vzorů pro mapování dědičnosti \cite[str. 78-79]{fowler}}{fig:Inheritance}

\subsubsection{Single Table Inheritance}

Single Table Inheritance, někdy také mapování pomocí unie, používá jednu databázovou tabulku pro celou hierarchii tříd. Atributy této tabulky tvoří unii atributů ze všech tříd v hierarchii. Tabulka navíc obsahuje sloupec, který u každého záznamu určuje k jaké třídě v hierarchii náleží. \\
Výhodou tohoto přístupu je, že se při získávání dat nemusí používat spojení tabulek, jednoduchá implementace a vysoká tolerance vůči změnám struktury tříd. \\
Jelikož tabulka obsahuje unii všech atributů, spousta sloupců často zůstává prázdných a její velikost se může projevit negativně na výkonu. Nelze také využít integritních omezení pro atributy, které nejsou sdíleny všemi třídami v hierarchii.

\subsubsection{Concrete Table Inheritance}

Concrete Table Inheritance definuje pro každou konkrétní třídu jednu tabulku v databázi. Tabulka obsahuje všechny atributy třídy a navíc i všechny atributy, které třída získala pomocí dědění. Konkrétní třídou je myšlena každá třída, která dědí z abstraktní třídy, ale sama abstraktní třídou není. Většinou jsou to třídy v hierarchii na pozici listu. \\
Při získávání záznamů není třeba spojení tabulek, mezi nevýhody však patří velká citlivost na změny. Při změně struktury nadtřídy je třeba změnit všechny tabulky mapující třídy, které z této nadtřídy dědí. Navíc jsou zde primární klíče rozděleny do všech tabulek, což znesnadňuje jejich správu a znemožňuje vazby pomocí cizích klíčů. \\
Concrete Table Inheritance se někdy označuje také jako horizontální mapování.

\subsubsection{Class Table Inheritance}

Při použití vzoru Class Table Inheritance je vytvořena tabulka v databázi pro každou třídu. Tato tabulka však obsahuje atributy, které jsou definované pouze v dané třídě. Výhodou je velmi jednoduché vytvoření tohoto mapování. Tabulka neobsahuje žádné prázdné sloupce a primární klíče jsou uloženy na jednom místě. Nevýhodou je složitost dotazů a jejich pomalé vyhodnocování, jelikož dochází ke spojování tabulek.  \\
Jiným názvem pro Class Table Inheritance bývá také Joined Table Inheritance nebo vertikální mapování.

\section{Srovnání existujících technologií pracujících na datové vrstvě}

Jelikož jedním z požadavků byl jazyk Python, budu se zde věnovat srovnání ORM rámců pro jazyk Python.

\subsection{Django ORM}

Django je rámec vytvořený v jazyce Python pro tvorbu webových aplikací. Je to jeden z nejpopulárnějších a nejpoužívanějších rámců pro tento jazyk \cite{pwiki}. Tvůrci tohoto rámce nazývají Django jako \uv{webový framework pro perfekcionisty s termíny}. \uv{Django podporuje rychlý vývoj a čisté, pragmatické konstrukce} \cite{django.cz}. Jednoho z autorů tohoto rámce, Adriana Holovatyho, inspiroval kytarista Django Reinhard natolik, že po něm pojmenoval tento framework \cite{aholovaty}.  \\

Django je známo hlavně pro své automaticky generované administrační rozhraní, obsáhlou dokumentaci a velkou komunitu uživatelů. Tento rámec se řídí návrhovým vzorem model-view-controller (MVC). ORM, které je součástí rámce představuje modelovou část. \\ 
ORM obsahuje i DBDAL a lze jej tak využít nezávisle na konkrétním SŘBD. Mezi podporované SŘBD patří Oracle, MySQL, PostgreSQL a SQLite. Pro SQLite jsou však některé funkce omezeny a nelze tak v případě jeho použití využít celkový potenciál ORM. Je to však dáno i omezenou funkčností tohoto SŘBD ve srovnání s ostatními. \\
ORM lze používat nezávisle na rámci Django. V současné době je Django ve verzi 1.5. Následující text tak popisuje vlastnosti, které jsou obsaženy v této verzi.

\subsubsection{Mapování v Django ORM}

Objektově-relační mapování je v Djangu inspirováno návrhovým vzorem Active Record. Třída, která abstrahuje databázovou tabulku, tedy kromě mapování obsahuje i aplikační logiku. Tuto třídu Django pojmenovává jako \uv{model}. \\
Aby třída získala vlastnosti modelu musí dědit z třídy \lstinline[style=custompython]|django.db.models.Model|. Při použití existující databáze lze definici této třídy automaticky vygenerovat pro každou tabulku. Django však preferuje přístup, při kterém se nejdříve vytvoří modely, a na základě této definice pak struktura v databázi. \\
Pro mapování sloupců používá model atributy, které jsou instancemi potomků třídy \lstinline[style=custompython]|django.db.models.Field|. Podporovány jsou pouze nejčastěji používané datové typy, což je dáno nezávislostí ORM na konkrétním SŘBD. Kromě těchto typů Django některé základní typy rozšiřuje a přidává k nim aplikační logiku, například atribut obsahující pouze emailové adresy. \\

Příkladem modelu je třída Author ve výpisu \ref{src:Mapping}. Tento model je namapován na databázovou tabulku myapp\_author, kterou Django vygeneruje automaticky. Výpis \ref{src:SQLAuthorMapping} zobrazuje vygenerované SQL pro SŘBD PostgreSQL pro model Author (kompletní SQL lze nalézt ve výpisu \ref{src:SQLMapping}). \\
Automaticky generován je i primární klíč, toto chování lze však změnit. Je ovšem vyžadováno, aby každá tabulka měla primární klíč. Dále pak musí primární klíč sestávat pouze z jednoho atributu, jelikož ORM nepodporuje složené klíče. \\
V definici modelu lze zadat i vytvoření indexu nebo unikátního integritního omezení pro konkrétní atribut. ORM indexy automaticky vytváří pro cizí klíče. \\

\begin{lstlisting}[style=custompython, emph={ Blog, Person, Author, Entry, VlogEntry}, emphstyle={\bfseries}, label=src:Mapping, caption=Modely jednoduché aplikace pro vytváření blogů]
from django.db import models

class Person(models.Model):
    first_name = models.CharField(max_length=50)
    last_name = models.CharField(max_length=50)

    class Meta:
        abstract = True

class Author(Person):
    email = models.EmailField(unique=True)
    biography = models.TextField()
    photo = models.ImageField(upload_to="photos/")

class Blog(models.Model):
    name = models.CharField(max_length=100, db_index=True)
    description = models.TextField()

class Entry(models.Model):
    blog = models.ForeignKey(Blog)
    headline = models.CharField(max_length=255)
    body_text = models.TextField()
    pub_date = models.DateField(auto_now_add=True)
    mod_date = models.DateField(auto_now=True)
    authors = models.ManyToManyField(Author)
    comments = models.IntegerField()
    rating = models.IntegerField()

class VlogEntry(Entry):
    video = models.URLField()

\end{lstlisting}

\begin{lstlisting}[label=src:SQLAuthorMapping, caption=Reprezentace modelu Author v PostgreSQL, style=customsql]
CREATE TABLE "myapp_author" (
    "id" serial NOT NULL PRIMARY KEY,
    "first_name" varchar(50) NOT NULL,
    "last_name" varchar(50) NOT NULL,
    "email" varchar(75) NOT NULL UNIQUE,
    "biography" text NOT NULL,
    "photo" varchar(100) NOT NULL
);
\end{lstlisting}

Django ORM podporuje i použití více databází najednou. Pro každý model je v takovém případě potřeba určit k jaké databázi náleží. \\
Výpis \ref{src:Mapping} zobrazuje jednoduchý model aplikace umožňující vytváření vlastních blogů. Tento model je použit pro všechny další příklady v této kapitole.

\paragraph{Instance modelu}

Instance modelu kromě dat řádku tabulky obsahují i metody pro práci s těmito daty. Mezi nejdůležitější patří metody pro validaci, uložení a mazání dat. Data se tedy před uložením validují i v ORM i v databázi. Toto má za důsledek mírně zvýšenou složitost, jelikož například při validování cizího klíče ORM kontroluje, zda-li v databázi existuje odkazovaný záznam. \\
Ukázku validace zobrazuje výpis \ref{src:Basic}. Na řádku 3 je provedena validace instance modelu Blog. Validace vypíše, že nebyl nastaven atribut \uv{description}, ale přesto se povede na řádku 5 objekt uložit do databáze. ORM totiž pro textová pole bez hodnoty vkládá prázdný řetězec. \\
Instance používají stejnou metodu pro vytvoření nového záznamu i pro uložení změn. Pokud instance neobsahuje primární klíč, je vytvořen nový záznam. Pokud klíč obsahuje, proběhne nejdříve kontrola, zda-li záznam se stejným primárním klíčem již existuje, a na základě výsledku se provede daný SQL příkaz. Ve výpisu \ref{src:Basic} je tedy na řádku 5 proveden \lstinline[style=customsql]|INSERT| a na řádku 9 proveden \lstinline[style=customsql]|UPDATE|. Tento výpis také zobrazuje na řádku 10 jiný způsob pro vytvoření nového záznamu.\\
Změny dat v instanci se v databázi projeví až při zavolání metody pro uložení. 

\paragraph{Mapování relací} Django ORM umožňuje definovat relace pro všechny způsoby popsané výše v sekci \ref{subsec:Relmapping}. Pro definování relace je potřeba využít tříd z balíku \lstinline[style=custompython]|django.db.models| a to \lstinline[style=custompython]|OneToOneField| pro relaci 1:1, \lstinline[style=custompython]|ForeignKey| pro 1:N nebo \lstinline[style=custompython]|ManyToManyField| pro N:M. Přístup k relačnímu objektu je pak realizován pomocí relačního atributu, jak zobrazuje výpis \ref{src:Basic} na řádku 13, kde je přistupováno k blogu konkrétního příspěvku. Pro získání relace je proveden dotaz do databáze. \\
K relaci lze přistoupit i přes tzv. zpětnou relaci, kdy je možné se z odkazovaného objektu dostat na odkazující. V případě relace 1:N nebo N:M je možné relaci dále filtrovat pomocí stejných pravidel jako při dotazování. Řádek 15 ve výpisu \ref{src:Basic} zobrazuje přístup pomocí zpětné relace ke všem příspěvkům v blogu, a dále tyto příspěvky filtruje jen na ty, které nemají žádné komentáře.\\
Při použití relace N:M je automaticky vytvořena vazební tabulka. Tuto tabulku lze předefinovat, pokud je potřeba, aby obsahovala doplňkové informace o vazbě. Ve výpisu \ref{src:Mapping} je mezi modely Author a Entry automaticky vytvořena vazební tabulka. Řádek 17 ve výpisu \ref{src:Basic} zobrazuje, jak do této vazební tabulky uložit záznam. Na řádku 18 je pak zase zobrazen přístup přes vazební tabulku ke všem relačním objektům, konkrétně je přistupováno ke všem autorům, kteří se podíleli na tvorbě příspěvku. \\
Je možno vytvořit i rekurzivní relaci, relaci na objekty stejného typu. \\

\paragraph{Mapování děčnosti}

ORM frameworku Django podporuje dva typy z výše popsaných návrhových vzorů mapování dědičnosti v sekci \ref{subsec:Inhmapping}. Concrete Table Inheritance a Class Table Inheritance. Oba dva případy jsou použity ve výpisu \ref{src:Mapping}. \\
Vzoru Concrete Table Inheritance využívá model Author, který dědí z abstraktního modelu Person. Model Person je označen jako abstraktní pomocí meta třídy. Instance tohoto modelu nelze ukládat, slouží pouze pro společné definice modelů, které z něj dědí. \\
Modely Entry a VlogEntry využívají Class Table Inheritance. Mezi těmito modely ORM automaticky vytvoří relaci 1:1. Pokud je instance nadřazeného modelu instancí i podřazeného modelu, je možné přistoupit přes relaci k datům podřazeného modelu. Řádek 20 ve výpisu \ref{src:Basic} zobrazuje přístup k instanci nadřazeného modelu. Řádek 22 pak přístup k instanci podřazeného modelu. Při získávání instance modelu VlogEntry z databáze, ORM automaticky získá data spojením tabulek i z modelu Entry.

\begin{lstlisting}[style=custompython, numbers=left, label=src:Basic, caption={Ukázka práce s instancí, relacemi a dědičností}]
>>> blog = Blog()
>>> blog.name = "David's new blog"
>>> blog.full_clean()
ValidationError: {'description': [u'This field cannot be blank.']}
>>> blog.save()
>>> blog.id
1
>>> blog.name = "Better name for the blog"
>>> blog.save()
>>> author = Author.objects.create(first_name="David", last_name="Krutký", email="david.krutky.st@vsb.cz")
>>> entry = VlogEntry(blog=blog, headline="New entry", comments=0, rating=0, video="http://example.com")
>>> entry.save()
>>> entry.blog
<Blog: Blog object>
>>> blog.entry_set.filter(comments=0)
[<Entry: Entry object>]
>>> entry.authors.add(author)
>>> entry.authors.all()
[<Author: Author object>]
>>> entry.entry_prt
<Entry: Entry object>
>>> entry.entry_prt.vlogentry
<VlogEntry: VlogEntry object>
\end{lstlisting}

\subsubsection{Dotazování}

Django ORM používá pro dotazování do databáze třídy, které pojmenovává jako \uv{manažery}. Každý manažer musí dědit z třídy \lstinline[style=custompython]|django.db.models.Manager| a každý model obsahuje jeden nebo více těchto manažerů. Implicitně lze manažer nalézt pod atributem modelu \uv{objects}. Takováto struktura tak odděluje manipulaci s celou tabulkou a manipulaci s řádkem tabulky. \\
Manažer poskytuje aplikační programové rozhraní (API) pomocí kterého abstrahuje SQL. Toto rozhraní nemá za úkol nahradit veškeré SQL, pouze usnadnit provádění častých dotazů. ORM však jako celek instruuje svými strukturami snahu nevyjadřovat výrazy pomocí SQL. \\
API obsahuje metody pomocí, kterých lze objekty filtrovat, agregovat, řadit, limitovat a na pozadí provádí SQL. Každá z těchto metod vrací objekt typu \uv{QuerySet}. QuerySet se stará o samotné provedení dotazu, získání dat z databáze a vytváření instancí modelů. QuerySet otálí s provedením dotazu, dokud data nejsou opravdu potřeba. Toto umožňuje jednotlivé metody pro dotazování řetězit. Je také možné QuerySet uložit do proměnné a vždy získat aktuální data, jelikož při řetězení metod je pokaždé vracen nový QuerySet. Ve výpisu \ref{src:Query} se tedy dotaz provede až na řádku 3, kdy je požadováno, aby se vypsal na terminál obsah objektu QuerySet. Na řádku 4 je pak zobrazeno jaký dotaz provedlo ORM. \\
Mezi nejdůležitější metody patří all, filter, exclude a get. Metoda all vrací všechny objekty daného modelu, filter jenom objekty, které splňují podmínku, exclude objekty, které podmínku nesplňují a get vrací jediný objekt pro danou podmínku. Podrobnosti zobrazuje výpis \ref{src:Query}. \\
QuerySet je možné dále omezovat pomocí standardní konstrukce používané pro objekty typu pole v jazyce Python. Řádky 11-14 ve výpisu \ref{src:Query} zobrazují toto limitování a SQL generované při dotazování do databáze. \\
ORM poskytuje i možnost zadat vlastní SQL, z jehož výsledku se pak vytvoří instance konkrétního modelu. Příklad zobrazuje řádek 15 ve výpisu \ref{src:Query}.

\begin{lstlisting}[style=custompython, numbers=left, label=src:Query, caption={Malá ukázka získávání dat z databáze}]
>>> queryset = Blog.objects.all() #Neprovádí se dotaz.
>>> filtered = queryset.filter(name="Better name for the blog")
>>> print filtered
#SELECT "myapp_blog"."id", "myapp_blog"."name", "myapp_blog"."description" FROM "myapp_blog" WHERE "myapp_blog"."name" = \'Better name for the blog\'
[<Blog: Blog object>] 
>>> queryset.exclude(name="Better name for the blog")
#SELECT "myapp_blog"."id", ... WHERE NOT ("myapp_blog"."name" = \'Better name\' )
>>> print Blog.objects.get(id=1)
#SELECT "myapp_blog"."id", ... WHERE "myapp_blog"."id" = 1
<Blog: Blog object>
>>> queryset[0]
#SELECT "myapp_blog"."id", ... FROM "myapp_blog" LIMIT 1
>>> queryset[2:5]
#SELECT "myapp_blog"."id", ... FROM "myapp_blog" LIMIT 3 OFFSET 2
>>> print Blog.objects.raw('SELECT * FROM "myapp_blog" ORDER BY "myapp_blog"."name"')
[<Blog: Blog object>, <Blog: Blog object>, ...] 
\end{lstlisting}

API pro dotazování poskytuje mnoho dalších funkcí, jejich popis je však nad rámec této diplomové práce. Cílem této sekce bylo pouze nastínit základní principy a ukázat základy syntaxe. 

\subsubsection{Optimalizace v Django ORM}

Django ORM umožňuje svými funkcemi optimalizovat některé náročnější operace. Přihlédnutím k těmto optimalizacím lze ve většině případů zlepšit výkon ORM. 

\paragraph{Ukládání do mezipaměti}

Pro každý provedený dotaz ORM automaticky kešuje výsledná data. Data nejsou uložená ve společné keši, ale ve výsledném objektu QuerySet nebo v konkrétní instanci. Jelikož však ORM při řetězení metod vrací vždy nový QuerySet, keš je při každé změně dotazu zahozena a data jsou načtena znovu. \\
Keš je použita v instanci v případě přístupu k relacím. Platí to však pouze, pokud relace odkazuje na konkrétní objekt. Keš se u relací M:N nebo zpětných relací u instance nepoužije \cite{dj-qscache}. \\
V případech, kdy výsledný QuerySet obsahuje mnoho záznamů, lze vypnutím této keše předejít zahlcení paměti \cite{dj-iterator}.

\paragraph{Načítání relací} 

Při neopatrném používání ORM může dojít k tzv. \textit{N+1 problému}. N+1 problém nastává, pokud je použit cyklus při získávání dat z databáze spolu s líným nahráváním. Většinou se tento problém projevuje u relací. Funkce \lstinline[style=custompython]|inefficient| ve výpisu \ref{src:Nplus1} zobrazuje, jak tento problém vypadá. Funkce se stará o jednoduchý výpis příspěvků a blogů, ve kterém jsou publikovány. Tato funkce však provede N+1 dotazů do tabáze. Jeden dotaz pro získání všech příspěvků a N dotazů pro získání blogu každého příspěvku. Tento kód navíc nebere v potaz ani to, že některé příspěvky mohou být publikovány ve stejném blogu. \\
ORM poskytuje řešení v podobě funkcí \lstinline[style=custompython]|select_related| a \lstinline[style=custompython]|prefetch_related|. \\ 
\lstinline[style=custompython]|select_related| se používá při přednačtení relací, které odkazují na konkrétní objekt. Při použití této funkce se všechny výsledné objekty a jejich relace načtou jedním dotazem pomocí spojení tabulek a relační objekty se uloží do keše k dané instanci. Funkce \lstinline[style=custompython]|efficient| ve výpisu \ref{src:Nplus1} tedy použije pouze jeden dotaz do databáze. \\
Stejný problém může nastat i při použití zpětných relací nebo v případech, kdy relace odkazuje na kolekci objektů. Pro tento případ se využívá funkce \lstinline[style=custompython]|prefetch_related.| Tato funkce byla přidána do ORM až ve verzi 1.4. Funkce \lstinline[style=custompython]|efficient_backward| ve výpisu \ref{src:Nplus1} využívá funkce \lstinline[style=custompython]|prefetch_related|. Při spuštění se provedou dva dotazy. Jeden pro získání všech blogů a druhý pro získání všech příspěvků za pomocí SQL \lstinline[style=customsql]|SELECT IN| klauzule. Výsledek se opět uloží do keše k daným instancím blogu. 

\paragraph{Omezení sloupců}

Implicitně se ORM pro každou tabulku dotazuje na všechny její atributy. Tento přístup může být obzvlášť náročný při obsáhlých tabulkách nebo objemných atributech, proto je možné dotazy omezit na konkrétní atributy tabulky. Tento postup se však doporučuje používat pouze, pokud není jisté, které konkrétní atributy budou použity. V opačném případě se doporučuje tabulku rozdělit, jelikož tato funkce mírně zvyšuje režijní náklady ORM \cite{dj-defer}.

\begin{lstlisting}[style=custompython, label=src:Nplus1, caption={N+1 problém a jeho řešení}]
def inefficient():
	for entry in Entry.objects.all():
		print 'Příspěvek: ', entry.headline
		print 'Publikován v blogu: ', entry.blog.name #Je proveden dotaz do databáze
		
def efficient():
	for entry in Entry.objects.select_related('blog').all():
		print 'Příspěvek: ', entry.headline
		print 'Publikován v blogu: ', entry.blog.name #Hodnota je získána z keše
		
def efficient_backward():
	for blog in Blog.objects.all().prefetch_related('entry_set'):
		print 'Blog: ', blog.name
		print 'Příspěvky v blogu: '
		for entry in blog.entry_set.all():#Hodnota je získána z keše
			print entry.headline
\end{lstlisting}

\paragraph{Hromadné operace}

ORM umožňuje pro objekty stejného typu hromadné operace. Mezi poskytované funkce patří hromadné vytváření, mazání i ukládání. Ve všech případech je však generován vždy jen jeden dotaz a ORM tak neumožňuje zpracovávání po dávkách. Další nevýhodou je, že při provedení těchto operací je přeskočena aplikační logika v modelech \cite{dj-bulk}.

\paragraph{Ukládání změn} Od verze 1.5 Django ORM umožňuje při ukládání instance uložit pouze specifikované atributy. Je tak možno uložit pouze změněná data a nezatěžovat databázi odesíláním všech atributů, což se v případě obsáhlého modelu může pozitivně projevit na výkonu. ORM však neposkytuje žádný mechanismus, který by tento přístup automatizoval, je tak potřeba implementovat vlastní sledování změn \cite{dj-save}.

\paragraph{Nevytváření instancí} ORM poskytuje možnost vyhnout se vytváření instancí z dat vrácených databází. Jelikož je proces vytváření instancí náročný, může tento postup v případech, kdy je potřeba získat pouze data, zlepšit celkový výkon \cite{dj-values}.

\paragraph{Zjišťování existence} Pro zjišťování existence záznamů v databázi používá ORM úsporný dotaz \lstinline[style=customsql]|SELECT (1) ... |. Využití této funkce je tedy většinou výhodnější než porovnávání výsledku obyčejného dotazu \cite{dj-exists}.

\subsubsection{Nevýhody Django ORM}

Django ORM představuje jednoduchou jednovrstvou abstrakci databáze poskytující O/R mapování. Má ovšem i své nevýhody. \\
Některé z nevýhod vychází z použití návrhového vzoru Active Record. Tento fakt předurčuje Django ORM pro použití v případech jednoduchého relačního modelu v databázi. U složitějších konstrukcí se projeví nevýhody tohoto vzoru (více v sekci \ref{subsubsec:ActiveRecord}). \\
ORM je také zaměřeno více na jednoduchost mapování a aplikační logiky a provádí ústupky na úkor databáze. Při použití jednoduchých aplikací lze toto přehlédnout, avšak v případech systémů, kdy databáze přetrvávají déle než aplikační kód, je toto řešení nevyhovující. \\
Další nevýhody plynou z použití O/R mapování. API ORM zakrývá skutečné dotazy prováděné nad databází, což může vést k neuváženému používání a zatěžování databáze. Je proto vždy nutné vědět, co ORM v konkrétních případech provádí. Toto má však za následek zdvojnásobení znalostí potřebných k nauční, jelikož je potřeba znát SQL i ORM API. Opět lze tento problém přehlédnout v případě jednoduchých aplikací, u složitějších aplikací je to však potřeba. \\
Mezi hlavní nevýhody pak patří nedostatečná abstrakce a inkonzistence v syntaxi API pro dotazování do databáze. ORM obsahuje dva typy konstrukcí pro získávání objektů z databáze. Tyto dva typy jsou vzájemně nekompatibilní, což způsobuje, že i poměrně jednoduché dotazy nelze pomocí API provést. Příkladem je dotaz, který pro každý blog vypíše celkový čas strávený modifikací jeho příspěvků. Výpis \ref{src:SimpleSQL} zobrazuje SQL dotaz pro získání těchto dat. Pomocí API ORM však nelze vytvořit adekvátní protějšek tohoto SQL \cite{dj-dis}.
\begin{lstlisting}[style=customsql, label=src:SimpleSQL, caption={Příklad dotazu, který nelze provést pomocí Django ORM API}]
SELECT blog_id, SUM(mod_date - pub_date) FROM myapp_entry GROUP BY blog_id;
\end{lstlisting}

Nevýhodou API je také nemožnost limitování dotazu při přednačtení relací pomocí funkce \lstinline[style=custompython]|prefetch_related|. Výpis \ref{src:Nplus1} zobrazuje příklad použití této funkce. Pokud je v tomto příkladu potřeba pro každý blog vypsat například pouze omezený počet příspěvků, lze zlepšit výkon limitováním dotazu na konkrétní počet. ORM však tuto funkci neumožňuje a vždy se při použití \lstinline[style=custompython]|prefetch_related| dotáže na všechny relační objekty. \\

ORM umožňuje zadat vlastní SQL dotazy, což řeší většinu problémů. Toto ovšem není dokonalé řešení, jelikož jsou tak ztraceny některé výhody ORM. V případě použití vlastního SQL se ztrácí možnost nezávislosti na konkrétní databázi, modelové schéma v aplikaci se rozpadá a začlenění dodatečné logiky přináší komplikace. \\

\subsubsection{Zhodnocení}
Navzdory nevýhodám uvedeným výše Django ORM funguje skvěle pro jednoduché případy a jeho použití ušetří mnoho času. A protože se jedná o projekt, který se každým dnem vyvíjí, je možné, že budou tyto nevýhody v budoucnu odstraněny.

\subsection{web2py DBAL}

web2py je rámec pro tvorbu webových aplikací napsaný v jazyce Python, který vznikl původně jako univerzitní projekt vytvořený profesorem Massimem Di Peirrem pro výukové účely \cite{wikiw2p}. Byl vytvořen s úmyslem co nejvíce usnadnit vývoj webových aplikací a problémy s tím spojené. Celý rámec je tak distribuován pomocí balíku, který v základu obsahuje integrované vývojové prostředí (IDE), webový server, relační databázi SQLite a dokonce i interpret jazyka Python. Není tedy potřeba nic instalovat, balík se rozbalí a ihned lze tento rámec používat \cite{web2py}. Rámec se řídí návrhovým vzorem MVC. \\
IDE sestává z administračního rozhraní, které je spuštěno na webovém serveru. Kód lze tak měnit v tomto IDE přímo na serveru a změny jsou viditelné ihned. Rámec obsahuje pro vytvořené aplikace i automaticky generované administrační rozhraní nad daty podobně jako Django. \\
web2py implementuje DBAL pro komunikaci s databází. Odlišnost této vrstvy od ORM je popisována jako \uv{mapování databázových tabulek a záznamů na instance a třídy reprezentující množiny a záznamy namísto vysoko-úrovňové abstrakce} \cite{wikiw2p}. Mezi podporované SŘBD podle oficiální dokumentace patří Firebird, IBM DB2, Informix, Ingres, Microsoft SQL Server, MySQL, Oracle, PostgreSQL, Google App Engine a mnoho dalších. Stejně jako Django ORM lze tuto vrstvu používat nezávisle na rámci.

\subsubsection{Mapování ve web2py DBAL}

\begin{lstlisting}[style=custompython, label=src:w2p-mapping, caption=Modely jednoduché aplikace pro vytváření blogů]
db = DAL("postgres://username:password@localhost/database")

person = db.Table(db, 'person',
	Field('first_name',  'string', length=50),
	Field('first_name',  'string', length=50))

db.define_table('author', 
	Field('email', 'string', unique=True), 
	Field('biography', 'text'),
	Field('photo', 'upload'),
	person)
	
db.define_table('blog', 
	Field('name', 'string', length=100), 
	Field('description', 'text'))

now = lambda: datetime.datetime.now()
db.define_table('entry', 
	Field('blog_id', 'relation blog'), 
	Field('headline', 'string'),
	Field('bodytext', 'text'),
	Field('pub_date', 'date', default=now),
	Field('mod_date', 'date', default=now, update=now),
	Field('bodytext', 'text'),
	Field('comments', 'integer'),
	Field('rating', 'integer'))
	
db.define_table('vblog', db.entry, Field('video', 'string'))

db.define_table('entry_author',
    Field('entry', 'reference entry'),
	Field('author', 'reference author'))
\end{lstlisting}

SQLite is included in Python and is the default web2py database. A connection string change allows connection to 
automaticke migrace
obsahuje skoro vse - jquery http://www.web2py.com/init/default/what
vytvari tabulky za behu
obsahuje datove typy, ktere jsou nefunkcni pro jine databaze
django i web2py umoznuji pouziti orm jako standalone
tabulky si ukladaji connection? a dokonce i sloupce, obsahuji referenci na connection, coz omezuje
sloupce maji metody pro validaci
migrace - define table vytvori tabulku pokud neexistuje, pokud ano provede ALTER, data ve sloupecku se snazi prevest, pro sloupce funguje i DROP, migrace pouze pro pridani, smazani nebo zmeny typu sloupce, neni to uplne automaticke nastavaji problemy je treba pouzivat fake\_migrate
migrace lze zakazat, pri migraci se ukladaji data do souboru
hodne se spoleha na to, ze se databaze nezmeni...
commit a rollback neni automaticky musi se volat
povoluje vykonavani raw SQL
umoznuje pracovat i s tabulkami
nepodporuje automaticke vytvareni indexu
umoznuje praci s existujicimi databazemi - unikatni autoincrement id, relace za pouziti pouze id
omezena podpora pro vsechny databaze,nektere funkce pouze pro nektere db, mnoho funkci je takovych
pri selectu automaticky zjistuje potrebne tabulky
do selectu se specifikujou sloupce, co se stane pokud specifikuji sloupce z ruzne tabulky?
obsahuje zkratky pro jednodussi kod
n+1 resi explicitnim joinem, funguji i zpetne relace - je to pouze zkratka
syntaxe je blizsi SQL umoznuje sirsi spektrum dotazu
%oddeleni carko v where nefunguje, jinak pouziva & a |
isempty method SQL pouziva normalni dotaz ne SELECT (1)
v nekterych mistech micha aplikacni logiku do DAL neni to ciste jenom na dotazovani
id neni vzdy ziskano z db
design kodu je velmi nepekny 1 soubor 10000 radku
obsahuje vlastni filtrovaci system, filtruje objekty, ktere jsou dotazany z db
update\_or\_insert funguje trochu jinak, pro vsechny sloupce, lze specifikovat
modely slouzi pouze pro definovani struktury, migrace a pro DBAL aby vedelo o strukture, pri existujici databazi je to opruz
parsovani natural language queries
web2py performs joins automatically and transparently when the query links two or more tables: db(db.person.id==db.thing.owner\_id).select() je to implicitni db join? je to stejne jako db(db.person).select(join=db.thing.on(db.person.id==db.thing.owner\_id)) ? neni to stejne
Many to many tabulka se musi specifikovat, joiny nejsou automaticke
list:<type>, and contains
konstrukce raw SQL, sestavovani dotazu je line, provedeni se vola pri db()
umoznuje import/export dat, i cele databaze do cvs, export do xml, html - mnoho nepotrebnych funkci, umoznuje verzovani pomoci db tabulky
umoznuje kesovat dotazy
relace lze definovat rekurzivne
dva typy dedicnosti - concrete, class
DAL si uklada metadata do souboru, lze pouzit bez definic tabulek avsak je potreba tyto soubory, coz je na prd, protoze soubory nemam jak ziskat
umoznuje kopirovat data mezi databazemi - i ruzne srbd, avsak myslim, ze to nefunguje 100%
mnoho nepodporovanych funkci v jinych dtabazich

\subsection{SQLAlchemy}
sql oriented

\section{Návrh knihovny pypg}

Úkolem této diplomové práce bylo vytvořit knihovnu pracující na datové vrstvě aplikačního softwaru. Je zbytečné znovu vynalézat kolo a proto bych zde chtěl popsat důvody, které mě vedly k vytvoření vlastní knihovny. \\
Žádná existující knihovna ani rámec nevyhovoval požadavkům.

\subsection{Motivy vytvoření vlastní knihovny}

Zaměřeno na více databází
ORM se snaží omezovat psaní SQL a prohlašuje, že k jeho užití není potřeba SQL znát. Toto je však chyba, jelikož bez znalosti SQL lze vytvářet pouze jednoduché aplikace. Je to dáno i tím, že pří složitější logice je třeba ORM obcházet pomocí vlastních dotazů. 
Je nutne znat SQL
zdvojnásobuje množství věcí k naučení: musíte umět SQL, abyste chápali, jak položit dotaz, a musíte umět přimět svoje ORM, aby ho za vás položilo
tak se nakonec mapování na objekty rozbije
Pokud máte firmu, kde Vám poskoci SQLka a obsluhu naťukají tak potom žádná. Pokud děláte aplikace sám pro sebe je každá ušetřená sekunda vývoje dobrá, optimalizuje se až je to potřeba.
ORM encourages you do to loops all over the place, by hiding logic in objects that themselves are instantiating other objects
Data pretrvavaji dele nez program, ktery je vyuziva
Pouziti databazovych struktur
API zakryva skutecne dotazy a to muze vest ke snizeni vykonu
\begin{lstlisting}[label=src:init,caption=Vytvoení nového reposite, style=customsql]
SELECT * FROM customer WHERE customername = 'test' AND customerid = 1; varchar serial
\end{lstlisting}
\begin{lstlisting}[label=src:test,caption=Test, style=custompython]
def f(x):
	"""Doc"""
    return "String" #comment 
>>> Place.filter(10) 
\end{lstlisting}

\section{Implementace knihovny pypg}

%-vysvetleni syntaxe, vsech mechanismu do podrobna
%-komentare ve zdrojovem kodu a principy clean code

\subsection{Dalsi funkce, ktere budou v budoucnu implementovany}
Connection pooling
tabulky a sloupce prece jen nakonec vypisovat pri chybach jenom pokud debug=True
pokud tabulka obsahuje vice relaci, zpetna vazba nefunguje uplne presne
sloupce pri joinu, ktere se jmenuji stejne podobne jako u web2py
raw sql, parsing sql
\section{Porovnani rychlosti pypg s ORM rámci}

\section{Závěr}
\label{sec:Conclusion}


\begin{thebibliography}{99}

\bibitem{fowler} Martin Fowler Patterns of en. application
\bibitem{msdn} http://msdn.microsoft.com/en-us/library/ee658109.aspx
\bibitem{dipl.net} Diplomova prace orm pro .net
\bibitem{fowler-ioc} http://martinfowler.com/bliki/InversionOfControl.html
\bibitem{dbprogrammer} http://database-programmer.blogspot.cz/2010/12/historical-perspective-of-orm-and.html
\bibitem{dresler} http://www.robertdresler.cz/2011/04/vicevrstve-architektury-aplikaci.html
\bibitem{pwiki} http://wiki.python.org/moin/WebFrameworks
\bibitem{django.cz} http://www.djangoproject.cz/
\bibitem{aholovaty} http://en.wikipedia.org/wiki/Adrian\_Holovaty
\bibitem{dj-qscache} https://docs.djangoproject.com/en/1.5/topics/db/queries/\#caching-and-querysets
\bibitem{dj-queries} https://docs.djangoproject.com/en/1.5/topics/db/queries/
\bibitem{dj-iterator} https://docs.djangoproject.com/en/1.5/ref/models/querysets/\#django.db.models.query.QuerySet.iterator
\bibitem{dj-values} https://docs.djangoproject.com/en/1.5/ref/models/querysets/\#django.db.models.query.QuerySet.values
\bibitem{dj-exists} https://docs.djangoproject.com/en/1.5/ref/models/querysets/\#exists
\bibitem{dj-defer} https://docs.djangoproject.com/en/1.5/ref/models/querysets/\#defer
\bibitem{dj-save} https://docs.djangoproject.com/en/1.5/ref/models/instances/\#specifying-which-fields-to-save
\bibitem{dj-bulk} https://docs.djangoproject.com/en/dev/topics/db/queries/\#updating-multiple-objects-at-once
\bibitem{dj-dis} http://www.youtube.com/watch?v=GxL9MnWlCwo
\bibitem{wikiw2p} http://en.wikipedia.org/wiki/Web2py
\bibitem{web2py} http://web2py.com/init/default/what

\end{thebibliography}


\appendix
\section{SQL vygenerované pomocí Django ORM z výpisu \ref{src:Mapping}}
\begin{lstlisting}[label=src:SQLMapping, caption=Reprezentace modelů z výpisu \ref{src:Mapping} v PostgreSQL, style=customsql]
CREATE TABLE "myapp_blog" (
    "id" serial NOT NULL PRIMARY KEY,
    "name" varchar(100) NOT NULL,
    "description" text NOT NULL
)
;
CREATE TABLE "myapp_author" (
    "id" serial NOT NULL PRIMARY KEY,
    "first_name" varchar(50) NOT NULL,
    "last_name" varchar(50) NOT NULL,
    "email" varchar(75) NOT NULL UNIQUE,
    "biography" text NOT NULL,
    "photo" varchar(100) NOT NULL
)
;
CREATE TABLE "myapp_entry_authors" (
    "id" serial NOT NULL PRIMARY KEY,
    "entry_id" integer NOT NULL,
    "author_id" integer NOT NULL REFERENCES "myapp_author" ("id") DEFERRABLE INITIALLY DEFERRED,
    UNIQUE ("entry_id", "author_id")
)
;
CREATE TABLE "myapp_entry" (
    "id" serial NOT NULL PRIMARY KEY,
    "blog_id" integer NOT NULL REFERENCES "myapp_blog" ("id") DEFERRABLE INITIALLY DEFERRED,
    "headline" varchar(255) NOT NULL,
    "body_text" text NOT NULL,
    "pub_date" date NOT NULL,
    "mod_date" date NOT NULL,
    "comments" integer NOT NULL,
    "rating" integer NOT NULL
)
;
ALTER TABLE "myapp_entry_authors" ADD CONSTRAINT "entry_id_refs_id_162c5c54" FOREIGN KEY ("entry_id") REFERENCES "myapp_entry" ("id") DEFERRABLE INITIALLY DEFERRED;
CREATE TABLE "myapp_vlogentry" (
    "entry_ptr_id" integer NOT NULL PRIMARY KEY REFERENCES "myapp_entry" ("id") DEFERRABLE INITIALLY DEFERRED,
    "video" varchar(200) NOT NULL
)
;
CREATE INDEX "myapp_blog_name" ON "myapp_blog" ("name");
CREATE INDEX "myapp_blog_name_like" ON "myapp_blog" ("name" varchar_pattern_ops);
CREATE INDEX "myapp_entry_blog_id" ON "myapp_entry" ("blog_id");
\end{lstlisting}
\clearpage


\end{document}
